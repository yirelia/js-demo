<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>router</title>
    <link rel="stylesheet" href="../css/index.css" />
    <script src="../js/x6/2.18.1/index.js"></script>
  </head>

  <body>
    <div id="app"></div>
  </body>
  <script type="module">
    class Graph {
      constructor() {}
    }

    class Point {
      constructor(x, y) {
        this.x = x;
        this.y = y;
      }

      static create(x, y) {
        return new Point(x, y);
      }

      static clone(x, y) {
        if (x instanceof Point) {
          return new Point(x.x, x.y);
        }
        return new Point(x, y);
      }
    }

    class AlgNode {
      constructor(x, y, val) {
        this.x = x;
        this.y = y;
        this.val = val;
        this.id = `node_${x}_${y}`;
      }

      visited() {
        this.val.setAttrByPath("body/fill", "rgb(105,105,105)");
      }

      toBeVisited() {
        this.val.setAttrByPath("body/fill", "green");
      }
      static create(x, y, val) {
        return new AlgNode(x, y, val);
      }
    }

    class Queue {
      constructor(queue = []) {
        this.data = [...queue];
        this.size = queue.length;
      }

      push(item) {
        this.data.push(item);
        this.size++;
      }

      pop() {
        if (this.size > 0) {
          this.size--;
        }
        return this.data.shift();
      }

      isEmpty() {
        return this.size === 0;
      }
    }
    const graph = new X6.Graph({
      container: document.getElementById("app"),
      grid: true,
      background: {
        color: "#f5f5f5",
      },
      async: false,
    });
    const allNodes = [];
    const nodeMap = new Map();
    let y = 100;
    const width = 40;
    const height = 40;
    const padding = 10;
    let index = 0;
    for (let i = 0; i < 10; i++) {
      let x = 100;
      for (let j = 0; j < 10; j++) {
        const id = `node_${i}_${j}`;
        const gNode = graph.addNode({
          id,
          x: x,
          y: y,
          width,
          height,
          label: `${index}`,
          attrs: {
            body: {
              strokeWidth: 1,
            },
          },
        });
        const node = AlgNode.create(i, j, gNode);
        nodeMap.set(id, node);
        index++;
        x += width + padding;
      }
      y += height + padding;
    }

    console.log(nodeMap);

    const getNeighbors = (node) => {
      const dir = [
        [1, 0], // RIGHT
        [0, 1], // DOWN
        [-1, 0], // LEFT
        [0, -1], // UP
      ];
      const result = [];
      for (let i = 0; i < dir.length; i++) {
        const [dx, dy] = dir[i];
        // const neighbor = {x: node.x + dx, y: node.y + dy};
        const neighbor = nodeMap.get(`node_${node.x + dx}_${node.y + dy}`);
        if (neighbor) {
          result.push(neighbor);
        }
      }
      return result;
    };

    function sleep(ms) {
      return new Promise((resolve) => setTimeout(resolve, ms));
    }

    async function breadFirstSearch(node, target) {
      const queue = new Queue([node]);
      const cameFrom = {};
      cameFrom[node.id] = null;
      const interval = 500;

      while (!queue.isEmpty()) {
        const current = queue.pop();
        current.visited();
        const neighbors = getNeighbors(current);
        if (current.id === target.id) {
          break;
        }
        for (const next of neighbors) {
          if (!cameFrom[next.id]) {
            cameFrom[next.id] = current;
            next.toBeVisited();
            queue.push(next);
          }
        }
        await sleep(interval);
      }

      const findPath = (source, target) =>  {
      const path = [];
      let current = target;
      while (current.id !== source.id) {
        path.push(current.val.getBBox().center);
        current = cameFrom[current.id];
      }
      path.push(source.val.getBBox().center);
      
      return path.reverse();
    }

    return findPath(node, target);
    }

    const source = nodeMap.get("node_3_1");
    const target = nodeMap.get("node_5_3");
    const paths = await breadFirstSearch (source, target);


    // const paths = findPath(target, source);

    // 格式化路径信息
    const formatPath = (paths) => {
        let pathString = `M ${paths[0].x} ${paths[0].y}`;
        for (let index = 1; index < paths.length; index++) {
          pathString += ` L ${paths[index].x} ${paths[index].y}`;
        }
        return pathString;
      };

      graph.addNode({
        shape: "path",
        attrs: {
          body: {
            d: formatPath(paths),
            stroke: `rgb(30,144,255)`,
          },
        },
      });

  </script>
</html>
